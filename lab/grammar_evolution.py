from lepl import *;

with DroppedSpace():
#   TTCN3Module ::= TTCN3ModuleKeyword ModuleId "{" [ ModuleDefinitionsList ] [ ModuleControlPart ] "}" [ WithStatement ] [ SemiColon ]
#   TTCN3ModuleKeyword ::= "module"
#   ModuleId ::= Identifier [ LanguageSpec ]
#   LanguageSpec ::= LanguageKeyword FreeText { "," FreeText }
#   LanguageKeyword ::= "language"
#   ModuleDefinitionsList ::= { ModuleDefinition [ SemiColon ] }+
#   ModuleDefinition ::= ( ( [ Visibility ] ( TypeDef | ConstDef | TemplateDef | ModuleParDef | FunctionDef | SignatureDef | TestcaseDef | AltstepDef | ImportDef | ExtFunctionDef | ExtConstDef ) ) | ( [ "public" ] GroupDef ) | ( [ "private" ] FriendModuleDef ) ) [ WithStatement ]
#   Visibility ::= "public" | "friend" | "private"
#   TypeDef ::= TypeDefKeyword TypeDefBody
#   TypeDefBody ::= StructuredTypeDef | SubTypeDef
#   TypeDefKeyword ::= "type"
#   StructuredTypeDef ::= RecordDef | UnionDef | SetDef | RecordOfDef | SetOfDef | EnumDef | PortDef | ComponentDef
#   RecordDef ::= RecordKeyword StructDefBody
#   RecordKeyword ::= "record"
#   StructDefBody ::= ( Identifier | AddressKeyword ) "{" [ StructFieldDef { "," StructFieldDef } ] "}"
#   StructFieldDef ::= ( Type | NestedTypeDef ) Identifier [ ArrayDef ] [ SubTypeSpec ] [ OptionalKeyword ]
#   NestedTypeDef ::= NestedRecordDef | NestedUnionDef | NestedSetDef | NestedRecordOfDef | NestedSetOfDef | NestedEnumDef
#   NestedRecordDef ::= RecordKeyword "{" [ StructFieldDef { "," StructFieldDef } ] "}"
#   NestedUnionDef ::= UnionKeyword "{" UnionFieldDef { "," UnionFieldDef } "}"
#   NestedSetDef ::= SetKeyword "{" [ StructFieldDef { "," StructFieldDef } ] "}"
#   NestedRecordOfDef ::= RecordKeyword [ StringLength ] OfKeyword ( Type | NestedTypeDef )
#   NestedSetOfDef ::= SetKeyword [ StringLength ] OfKeyword ( Type | NestedTypeDef )
#   NestedEnumDef ::= EnumKeyword "{" EnumerationList "}"
#   OptionalKeyword ::= "optional"
#   UnionDef ::= UnionKeyword UnionDefBody
#   UnionKeyword ::= "union"
#   UnionDefBody ::= ( Identifier | AddressKeyword ) "{" UnionFieldDef { "," UnionFieldDef } "}"
#   UnionFieldDef ::= ( Type | NestedTypeDef ) Identifier [ ArrayDef ] [ SubTypeSpec ]
#   SetDef ::= SetKeyword StructDefBody
#   SetKeyword ::= "set"
#   RecordOfDef ::= RecordKeyword [ StringLength ] OfKeyword StructOfDefBody
#   OfKeyword ::= "of"
#   StructOfDefBody ::= ( Type | NestedTypeDef ) ( Identifier | AddressKeyword ) [ SubTypeSpec ]
#   SetOfDef ::= SetKeyword [ StringLength ] OfKeyword StructOfDefBody
#   EnumDef ::= EnumKeyword ( Identifier | AddressKeyword ) "{" EnumerationList "}"
#   EnumKeyword ::= "enumerated"
#   EnumerationList ::= Enumeration { "," Enumeration }
#   Enumeration ::= Identifier [ "(" [ Minus ] Number ")" ]
#   SubTypeDef ::= Type ( Identifier | AddressKeyword ) [ ArrayDef ] [ SubTypeSpec ]
#   SubTypeSpec ::= AllowedValuesSpec [ StringLength ] | StringLength
#   AllowedValuesSpec ::= "(" ( ( TemplateOrRange { "," TemplateOrRange } ) | CharStringMatch ) ")"
#   TemplateOrRange ::= RangeDef | TemplateBody | Type
#   RangeDef ::= Bound ".." Bound
#   StringLength ::= LengthKeyword "(" SingleExpression [ ".." Bound ] ")"
#   LengthKeyword ::= "length"
#   PortDef ::= PortKeyword PortDefBody
#   PortDefBody ::= Identifier PortDefAttribs
#   PortKeyword ::= "port"
#   PortDefAttribs ::= MessageAttribs | ProcedureAttribs | MixedAttribs
#   MessageAttribs ::= MessageKeyword "{" { ( AddressDecl | MessageList | ConfigParamDef ) [ SemiColon ] }+ "}"
#   ConfigParamDef ::= MapParamDef | UnmapParamDef
#   MapParamDef ::= MapKeyword ParamKeyword "(" FormalValuePar { "," FormalValuePar } ")"
#   UnmapParamDef ::= UnmapKeyword ParamKeyword "(" FormalValuePar { "," FormalValuePar } ")"
#   AddressDecl ::= AddressKeyword Type
#   MessageList ::= Direction AllOrTypeList
#   Direction ::= InParKeyword | OutParKeyword | InOutParKeyword
#   MessageKeyword ::= "message"
#   AllOrTypeList ::= AllKeyword | TypeList
#   AllKeyword ::= "all"
#   TypeList ::= Type { "," Type }
#   ProcedureAttribs ::= ProcedureKeyword "{" { ( AddressDecl | ProcedureList | ConfigParamDef ) [ SemiColon ] }+ "}"
#   ProcedureKeyword ::= "procedure"
#   ProcedureList ::= Direction AllOrSignatureList
#   AllOrSignatureList ::= AllKeyword | SignatureList
#   SignatureList ::= Signature { "," Signature }
#   MixedAttribs ::= MixedKeyword "{" { ( AddressDecl | MixedList | ConfigParamDef ) [ SemiColon ] }+ "}"
#   MixedKeyword ::= "mixed"
#   MixedList ::= Direction ProcOrTypeList
#   ProcOrTypeList ::= AllKeyword | ( ProcOrType { "," ProcOrType } )
#   ProcOrType ::= Signature | Type
#   ComponentDef ::= ComponentKeyword Identifier [ ExtendsKeyword ComponentType { "," ComponentType } ] "{" [ ComponentDefList ] "}"
#   ComponentKeyword ::= "component"
#   ExtendsKeyword ::= "extends"
#   ComponentType ::= ExtendedIdentifier
#   ComponentDefList ::= { ComponentElementDef [ WithStatement ] [ SemiColon ] }
#   ComponentElementDef ::= PortInstance | VarInstance | TimerInstance | ConstDef
#   PortInstance ::= PortKeyword ExtendedIdentifier PortElement { "," PortElement }
#   PortElement ::= Identifier [ ArrayDef ]
#   ConstDef ::= ConstKeyword Type ConstList
#   ConstList ::= SingleConstDef { "," SingleConstDef }
#   SingleConstDef ::= Identifier [ ArrayDef ] AssignmentChar ConstantExpression
#   ConstKeyword ::= "const"
#   TemplateDef ::= TemplateKeyword [ TemplateRestriction ] BaseTemplate [ DerivedDef ] AssignmentChar TemplateBody
#   BaseTemplate ::= ( Type | Signature ) Identifier [ "(" TemplateOrValueFormalParList ")" ]
#   TemplateKeyword ::= "template"
#   DerivedDef ::= ModifiesKeyword ExtendedIdentifier
#   ModifiesKeyword ::= "modifies"
#   TemplateOrValueFormalParList ::= TemplateOrValueFormalPar { "," TemplateOrValueFormalPar }
#   TemplateOrValueFormalPar ::= FormalValuePar | FormalTemplatePar
#   TemplateBody ::= ( SimpleSpec | FieldSpecList | ArrayValueOrAttrib ) [ ExtraMatchingAttributes ]
#   SimpleSpec ::= ( SingleExpression [ "&" SimpleTemplateSpec ] ) | SimpleTemplateSpec
#   SimpleTemplateSpec ::= SingleTemplateExpression [ "&" SimpleSpec ]
#   SingleTemplateExpression ::= MatchingSymbol | ( TemplateRefWithParList [ ExtendedFieldReference ] )
#   FieldSpecList ::= "{" FieldSpec { "," FieldSpec } "}"
#   FieldSpec ::= FieldReference AssignmentChar ( TemplateBody | Minus )
#   FieldReference ::= StructFieldRef | ArrayOrBitRef | ParRef
#   StructFieldRef ::= Identifier | PredefinedType | TypeReference
#   ParRef ::= Identifier
#   ArrayOrBitRef ::= "[" FieldOrBitNumber "]"
#   FieldOrBitNumber ::= SingleExpression
#   ArrayValueOrAttrib ::= "{" [ ArrayElementSpecList ] "}"
#   ArrayElementSpecList ::= ArrayElementSpec { "," ArrayElementSpec }
#   ArrayElementSpec ::= Minus | PermutationMatch | TemplateBody
#   MatchingSymbol ::= Complement | ( AnyValue [ WildcardLengthMatch ] ) | ( AnyOrOmit [ WildcardLengthMatch ] ) | ListOfTemplates | Range | BitStringMatch | HexStringMatch | OctetStringMatch | CharStringMatch | SubsetMatch | SupersetMatch
#   ExtraMatchingAttributes ::= StringLength | IfPresentKeyword | ( StringLength IfPresentKeyword )
#   BitStringMatch ::= "'" { BinOrMatch } "'" "B"
#   BinOrMatch ::= Bin | AnyValue | AnyOrOmit
#   HexStringMatch ::= "'" { HexOrMatch } "'" "H"
#   HexOrMatch ::= Hex | AnyValue | AnyOrOmit
#   OctetStringMatch ::= "'" { OctOrMatch } "'" "O"
#   OctOrMatch ::= Oct | AnyValue | AnyOrOmit
#   CharStringMatch ::= PatternKeyword PatternParticle { "&" PatternParticle }
#   PatternParticle ::= Pattern | ReferencedValue
#   PatternKeyword ::= "pattern"
#   Pattern ::= """ { PatternElement } """
#   PatternElement ::= ( ( "\" ( "?" | "*" | "\" | "[" | "]" | "{" | "}" | """ | "|" | "(" | ")" | "#" | "+" | "d" | "w" | "t" | "n" | "r" | "s" | "b" ) ) | ( "?" | "*" | "\" | "|" | "+" ) | ( "[" [ "^" ] [ { PatternClassChar [ "-" PatternClassChar ] } ] "]" ) | ( "{" [ "\" ] ReferencedValue "}" ) | ( "\" "N" "{" ( ReferencedValue | Type ) "}" ) | ( """ """ ) | ( "(" PatternElement ")" ) | ( "#" ( Num | ( "(" Num "," [ Num ] ")" ) | ( "(" "," Num ")" ) ) ) | PatternChar )
#   PatternChar ::= NonSpecialPatternChar | PatternQuadruple
#   NonSpecialPatternChar ::= Char
#   PatternClassChar ::= NonSpecialPatternClassChar | PatternQuadruple | "\" EscapedPatternClassChar
#   NonSpecialPatternClassChar ::= Char
#   EscapedPatternClassChar ::= "[" | "-" | "^" | "]"
#   PatternQuadruple ::= "\" "q" "(" Number "," Number "," Number "," Number ")"
#   Complement ::= ComplementKeyword ListOfTemplates
#   ComplementKeyword ::= "complement"
#   ListOfTemplates ::= "(" TemplateListItem { "," TemplateListItem } ")"
#   TemplateListItem ::= TemplateBody | AllElementsFrom
#   AllElementsFrom ::= AllKeyword FromKeyword TemplateBody
#   SubsetMatch ::= SubsetKeyword ListOfTemplates
#   SubsetKeyword ::= "subset"
#   SupersetMatch ::= SupersetKeyword ListOfTemplates
#   SupersetKeyword ::= "superset"
#   PermutationMatch ::= PermutationKeyword ListOfTemplates
#   PermutationKeyword ::= "permutation"
#   AnyValue ::= "?"
#   AnyOrOmit ::= "*"
#   TemplateList ::= "(" TemplateBody { "," TemplateBody }+ ")"
#   WildcardLengthMatch ::= LengthKeyword "(" SingleExpression ")"
#   IfPresentKeyword ::= "ifpresent"
#   PresentKeyword ::= "present"
#   Range ::= "(" Bound ".." Bound ")"
#   Bound ::= ( [ "!" ] SingleExpression ) | ( [ Minus ] InfinityKeyword )
#   InfinityKeyword ::= "infinity"
#   TemplateInstanceAssignment ::= Identifier ":=" InLineTemplate
#   TemplateRefWithParList ::= ExtendedIdentifier [ TemplateActualParList ]
#   InLineTemplate ::= [ ( Type | Signature ) Colon ] [ DerivedRefWithParList AssignmentChar ] TemplateBody
#   DerivedRefWithParList ::= ModifiesKeyword TemplateRefWithParList
#   TemplateActualParList ::= "(" [ ( TemplateInstanceActualPar { "," TemplateInstanceActualPar } ) | ( TemplateInstanceAssignment { "," TemplateInstanceAssignment } ) ] ")"
#   TemplateInstanceActualPar ::= InLineTemplate | Minus
#   TemplateOps ::= MatchOp | ValueofOp
#   MatchOp ::= MatchKeyword "(" Expression "," InLineTemplate ")"
#   MatchKeyword ::= "match"
#   ValueofOp ::= ValueofKeyword "(" InLineTemplate ")"
#   ValueofKeyword ::= "valueof"
#   FunctionDef ::= FunctionKeyword Identifier "(" [ FunctionFormalParList ] ")" [ RunsOnSpec ] [ ReturnType ] StatementBlock
#   FunctionKeyword ::= "function"
#   FunctionFormalParList ::= FunctionFormalPar { "," FunctionFormalPar }
#   FunctionFormalPar ::= FormalValuePar | FormalTimerPar | FormalTemplatePar | FormalPortPar
#   ReturnType ::= ReturnKeyword [ TemplateKeyword | RestrictedTemplate ] Type
#   ReturnKeyword ::= "return"
#   RunsOnSpec ::= RunsKeyword OnKeyword ComponentType
#   RunsKeyword ::= "runs"
#   OnKeyword ::= "on"
#   MTCKeyword ::= "mtc"
#   StatementBlock ::= "{" [ FunctionDefList ] [ FunctionStatementList ] "}"
#   FunctionDefList ::= { ( FunctionLocalDef | FunctionLocalInst ) [ WithStatement ] [ SemiColon ] }+
#   FunctionStatementList ::= { FunctionStatement [ SemiColon ] }+
#   FunctionLocalInst ::= VarInstance | TimerInstance
#   FunctionLocalDef ::= ConstDef | TemplateDef
#   FunctionStatement ::= ConfigurationStatements | TimerStatements | CommunicationStatements | BasicStatements | BehaviourStatements | SetLocalVerdict | SUTStatements | TestcaseOperation
#   FunctionInstance ::= FunctionRef "(" [ FunctionActualParList ] ")"
#   FunctionRef ::= [ Identifier Dot ] ( Identifier | PreDefFunctionIdentifier )
#   PreDefFunctionIdentifier ::= Identifier
#   FunctionActualParList ::= ( FunctionActualPar { "," FunctionActualPar } ) | ( FunctionActualParAssignment { "," FunctionActualParAssignment } )
#   FunctionActualPar ::= ArrayIdentifierRef | InLineTemplate | ComponentRef | Minus
#   FunctionActualParAssignment ::= TemplateInstanceAssignment | ComponentRefAssignment | ArrayIdentifierRefAssignment
#   ArrayIdentifierRefAssignment ::= Identifier ":=" ArrayIdentifierRef
#   SignatureDef ::= SignatureKeyword Identifier "(" [ SignatureFormalParList ] ")" [ ReturnType | NoBlockKeyword ] [ ExceptionSpec ]
#   SignatureKeyword ::= "signature"
#   SignatureFormalParList ::= FormalValuePar { "," FormalValuePar }
#   ExceptionSpec ::= ExceptionKeyword "(" TypeList ")"
#   ExceptionKeyword ::= "exception"
#   Signature ::= ExtendedIdentifier
#   NoBlockKeyword ::= "noblock"
#   TestcaseDef ::= TestcaseKeyword Identifier "(" [ TemplateOrValueFormalParList ] ")" ConfigSpec StatementBlock
#   TestcaseKeyword ::= "testcase"
#   ConfigSpec ::= RunsOnSpec [ SystemSpec ]
#   SystemSpec ::= SystemKeyword ComponentType
#   SystemKeyword ::= "system"
#   TestcaseInstance ::= ExecuteKeyword "(" ExtendedIdentifier "(" [ TestcaseActualParList ] ")" [ "," ( Expression | Minus ) [ "," SingleExpression ] ] ")"
#   ExecuteKeyword ::= "execute"
#   TestcaseActualParList ::= ( TemplateInstanceActualPar { "," TemplateInstanceActualPar } ) | ( TemplateInstanceAssignment { "," TemplateInstanceAssignment } )
#   AltstepDef ::= AltstepKeyword Identifier "(" [ FunctionFormalParList ] ")" [ RunsOnSpec ] "{" AltstepLocalDefList AltGuardList "}"
#   AltstepKeyword ::= "altstep"
#   AltstepLocalDefList ::= { AltstepLocalDef [ WithStatement ] [ SemiColon ] }
#   AltstepLocalDef ::= VarInstance | TimerInstance | ConstDef | TemplateDef
#   AltstepInstance ::= ExtendedIdentifier "(" [ FunctionActualParList ] ")"
#   ImportDef ::= ImportKeyword ImportFromSpec ( AllWithExcepts | ( "{" ImportSpec "}" ) )
#   ImportKeyword ::= "import"
#   AllWithExcepts ::= AllKeyword [ ExceptsDef ]
#   ExceptsDef ::= ExceptKeyword "{" ExceptSpec "}"
#   ExceptKeyword ::= "except"
#   ExceptSpec ::= { ExceptElement [ SemiColon ] }
#   ExceptElement ::= ExceptGroupSpec | ExceptTypeDefSpec | ExceptTemplateSpec | ExceptConstSpec | ExceptTestcaseSpec | ExceptAltstepSpec | ExceptFunctionSpec | ExceptSignatureSpec | ExceptModuleParSpec
#   ExceptGroupSpec ::= GroupKeyword ( QualifiedIdentifierList | AllKeyword )
#   IdentifierListOrAll ::= IdentifierList | AllKeyword
#   ExceptTypeDefSpec ::= TypeDefKeyword IdentifierListOrAll
#   ExceptTemplateSpec ::= TemplateKeyword IdentifierListOrAll
#   ExceptConstSpec ::= ConstKeyword IdentifierListOrAll
#   ExceptTestcaseSpec ::= TestcaseKeyword IdentifierListOrAll
#   ExceptAltstepSpec ::= AltstepKeyword IdentifierListOrAll
#   ExceptFunctionSpec ::= FunctionKeyword IdentifierListOrAll
#   ExceptSignatureSpec ::= SignatureKeyword IdentifierListOrAll
#   ExceptModuleParSpec ::= ModuleParKeyword IdentifierListOrAll
#   ImportSpec ::= { ImportElement [ SemiColon ] }
#   ImportElement ::= ImportGroupSpec | ImportTypeDefSpec | ImportTemplateSpec | ImportConstSpec | ImportTestcaseSpec | ImportAltstepSpec | ImportFunctionSpec | ImportSignatureSpec | ImportModuleParSpec | ImportImportSpec
#   ImportFromSpec ::= FromKeyword ModuleId [ RecursiveKeyword ]
#   RecursiveKeyword ::= "recursive"
#   ImportGroupSpec ::= GroupKeyword ( GroupRefListWithExcept | AllGroupsWithExcept )
#   GroupRefListWithExcept ::= QualifiedIdentifierWithExcept { "," QualifiedIdentifierWithExcept }
#   AllGroupsWithExcept ::= AllKeyword [ ExceptKeyword QualifiedIdentifierList ]
#   QualifiedIdentifierWithExcept ::= QualifiedIdentifier [ ExceptsDef ]
#   IdentifierListOrAllWithExcept ::= IdentifierList | AllWithExcept
#   ImportTypeDefSpec ::= TypeDefKeyword IdentifierListOrAllWithExcept
#   AllWithExcept ::= AllKeyword [ ExceptKeyword IdentifierList ]
#   ImportTemplateSpec ::= TemplateKeyword IdentifierListOrAllWithExcept
#   ImportConstSpec ::= ConstKeyword IdentifierListOrAllWithExcept
#   ImportAltstepSpec ::= AltstepKeyword IdentifierListOrAllWithExcept
#   ImportTestcaseSpec ::= TestcaseKeyword IdentifierListOrAllWithExcept
#   ImportFunctionSpec ::= FunctionKeyword IdentifierListOrAllWithExcept
#   ImportSignatureSpec ::= SignatureKeyword IdentifierListOrAllWithExcept
#   ImportModuleParSpec ::= ModuleParKeyword IdentifierListOrAllWithExcept
#   ImportImportSpec ::= ImportKeyword AllKeyword
#   GroupDef ::= GroupKeyword Identifier "{" [ ModuleDefinitionsList ] "}"
#   GroupKeyword ::= "group"
#   ExtFunctionDef ::= ExtKeyword FunctionKeyword Identifier "(" [ FunctionFormalParList ] ")" [ ReturnType ]
#   ExtKeyword ::= "external"
#   ExtConstDef ::= ExtKeyword ConstKeyword Type IdentifierList
#   ModuleParDef ::= ModuleParKeyword ( ModulePar | ( "{" MultitypedModuleParList "}" ) )
#   ModuleParKeyword ::= "modulepar"
#   MultitypedModuleParList ::= { ModulePar [ SemiColon ] }
#   ModulePar ::= Type ModuleParList
#   ModuleParList ::= Identifier [ AssignmentChar ConstantExpression ] { "," Identifier [ AssignmentChar ConstantExpression ] }
#   FriendModuleDef ::= "friend" "module" IdentifierList [ SemiColon ]
#   ModuleControlPart ::= ControlKeyword "{" ModuleControlBody "}" [ WithStatement ] [ SemiColon ]
#   ControlKeyword ::= "control"
#   ModuleControlBody ::= [ ControlStatementOrDefList ]
#   ControlStatementOrDefList ::= { ControlStatementOrDef [ SemiColon ] }+
#   ControlStatementOrDef ::= ( FunctionLocalDef | FunctionLocalInst ) [ WithStatement ] | ControlStatement
#   ControlStatement ::= TimerStatements | BasicStatements | BehaviourStatements | SUTStatements | StopKeyword
#   VarInstance ::= VarKeyword ( ( Type VarList ) | ( ( TemplateKeyword | RestrictedTemplate ) Type TempVarList ) )
#   VarList ::= SingleVarInstance { "," SingleVarInstance }
#   SingleVarInstance ::= Identifier [ ArrayDef ] [ AssignmentChar Expression ]
#   VarKeyword ::= "var"
#   TempVarList ::= SingleTempVarInstance { "," SingleTempVarInstance }
#   SingleTempVarInstance ::= Identifier [ ArrayDef ] [ AssignmentChar TemplateBody ]
#   VariableRef ::= Identifier [ ExtendedFieldReference ]
#   TimerInstance ::= TimerKeyword VarList
#   TimerKeyword ::= "timer"
#   ArrayIdentifierRef ::= Identifier { ArrayOrBitRef }
#   ConfigurationStatements ::= ConnectStatement | MapStatement | DisconnectStatement | UnmapStatement | DoneStatement | KilledStatement | StartTCStatement | StopTCStatement | KillTCStatement
#   ConfigurationOps ::= CreateOp | SelfOp | SystemKeyword | MTCKeyword | RunningOp | AliveOp
#   CreateOp ::= ComponentType Dot CreateKeyword [ "(" ( SingleExpression | Minus ) [ "," SingleExpression ] ")" ] [ AliveKeyword ]
#   SelfOp ::= "self"
#   DoneStatement ::= ComponentId Dot DoneKeyword
#   KilledStatement ::= ComponentId Dot KilledKeyword
#   ComponentId ::= ComponentOrDefaultReference | ( AnyKeyword | AllKeyword ) ComponentKeyword
#   DoneKeyword ::= "done"
#   KilledKeyword ::= "killed"
#   RunningOp ::= ComponentId Dot RunningKeyword
#   RunningKeyword ::= "running"
#   AliveOp ::= ComponentId Dot AliveKeyword
#   CreateKeyword ::= "create"
#   AliveKeyword ::= "alive"
#   ConnectStatement ::= ConnectKeyword SingleConnectionSpec
#   ConnectKeyword ::= "connect"
#   SingleConnectionSpec ::= "(" PortRef "," PortRef ")"
#   PortRef ::= ComponentRef Colon ArrayIdentifierRef
#   ComponentRef ::= ComponentOrDefaultReference | SystemKeyword | SelfOp | MTCKeyword
#   ComponentRefAssignment ::= Identifier ":=" ComponentRef
#   DisconnectStatement ::= DisconnectKeyword [ SingleConnectionSpec | AllConnectionsSpec | AllPortsSpec | AllCompsAllPortsSpec ]
#   AllConnectionsSpec ::= "(" PortRef ")"
#   AllPortsSpec ::= "(" ComponentRef ":" AllKeyword PortKeyword ")"
#   AllCompsAllPortsSpec ::= "(" AllKeyword ComponentKeyword ":" AllKeyword PortKeyword ")"
#   DisconnectKeyword ::= "disconnect"
#   MapStatement ::= MapKeyword SingleConnectionSpec [ ParamClause ]
#   ParamClause ::= ParamKeyword FunctionActualParList
#   MapKeyword ::= "map"
#   UnmapStatement ::= UnmapKeyword [ SingleConnectionSpec [ ParamClause ] | AllConnectionsSpec [ ParamClause ] | AllPortsSpec | AllCompsAllPortsSpec ]
#   UnmapKeyword ::= "unmap"
#   StartTCStatement ::= ComponentOrDefaultReference Dot StartKeyword "(" FunctionInstance ")"
#   StartKeyword ::= "start"
#   StopTCStatement ::= StopKeyword | ( ComponentReferenceOrLiteral | AllKeyword ComponentKeyword ) Dot StopKeyword
#   ComponentReferenceOrLiteral ::= ComponentOrDefaultReference | MTCKeyword | SelfOp
#   KillTCStatement ::= KillKeyword | ( ( ComponentReferenceOrLiteral | AllKeyword ComponentKeyword ) Dot KillKeyword )
#   ComponentOrDefaultReference ::= VariableRef | FunctionInstance
#   KillKeyword ::= "kill"
#   CommunicationStatements ::= SendStatement | CallStatement | ReplyStatement | RaiseStatement | ReceiveStatement | TriggerStatement | GetCallStatement | GetReplyStatement | CatchStatement | CheckStatement | ClearStatement | StartStatement | StopStatement | HaltStatement | CheckStateStatement
#   SendStatement ::= ArrayIdentifierRef Dot PortSendOp
#   PortSendOp ::= SendOpKeyword "(" InLineTemplate ")" [ ToClause ]
#   SendOpKeyword ::= "send"
#   ToClause ::= ToKeyword ( InLineTemplate | AddressRefList | AllKeyword ComponentKeyword )
#   AddressRefList ::= "(" InLineTemplate { "," InLineTemplate } ")"
#   ToKeyword ::= "to"
#   CallStatement ::= ArrayIdentifierRef Dot PortCallOp [ PortCallBody ]
#   PortCallOp ::= CallOpKeyword "(" CallParameters ")" [ ToClause ]
#   CallOpKeyword ::= "call"
#   CallParameters ::= InLineTemplate [ "," CallTimerValue ]
#   CallTimerValue ::= Expression | NowaitKeyword
#   NowaitKeyword ::= "nowait"
#   PortCallBody ::= "{" CallBodyStatementList "}"
#   CallBodyStatementList ::= { CallBodyStatement [ SemiColon ] }+
#   CallBodyStatement ::= CallBodyGuard StatementBlock
#   CallBodyGuard ::= AltGuardChar CallBodyOps
#   CallBodyOps ::= GetReplyStatement | CatchStatement
#   ReplyStatement ::= ArrayIdentifierRef Dot PortReplyOp
#   PortReplyOp ::= ReplyKeyword "(" InLineTemplate [ ReplyValue ] ")" [ ToClause ]
#   ReplyKeyword ::= "reply"
#   ReplyValue ::= ValueKeyword Expression
#   RaiseStatement ::= ArrayIdentifierRef Dot PortRaiseOp
#   PortRaiseOp ::= RaiseKeyword "(" Signature "," InLineTemplate ")" [ ToClause ]
#   RaiseKeyword ::= "raise"
#   ReceiveStatement ::= PortOrAny Dot PortReceiveOp
#   PortOrAny ::= ArrayIdentifierRef | AnyKeyword PortKeyword
#   PortReceiveOp ::= ReceiveOpKeyword [ "(" InLineTemplate ")" ] [ FromClause ] [ PortRedirect ]
#   ReceiveOpKeyword ::= "receive"
#   FromClause ::= FromKeyword ( InLineTemplate | AddressRefList | AnyKeyword ComponentKeyword )
#   FromKeyword ::= "from"
#   PortRedirect ::= PortRedirectSymbol ( ValueSpec [ SenderSpec ] | SenderSpec )
#   PortRedirectSymbol ::= "->"
#   ValueSpec ::= ValueKeyword ( VariableRef | ( "(" SingleValueSpec { "," SingleValueSpec } ")" ) )
#   SingleValueSpec ::= VariableRef [ AssignmentChar FieldReference ExtendedFieldReference ]
#   ValueKeyword ::= "value"
#   SenderSpec ::= SenderKeyword VariableRef
#   SenderKeyword ::= "sender"
#   TriggerStatement ::= PortOrAny Dot PortTriggerOp
#   PortTriggerOp ::= TriggerOpKeyword [ "(" InLineTemplate ")" ] [ FromClause ] [ PortRedirect ]
#   TriggerOpKeyword ::= "trigger"
#   GetCallStatement ::= PortOrAny Dot PortGetCallOp
#   PortGetCallOp ::= GetCallOpKeyword [ "(" InLineTemplate ")" ] [ FromClause ] [ PortRedirectWithParam ]
#   GetCallOpKeyword ::= "getcall"
#   PortRedirectWithParam ::= PortRedirectSymbol RedirectWithParamSpec
#   RedirectWithParamSpec ::= ParamSpec [ SenderSpec ] | SenderSpec
#   ParamSpec ::= ParamKeyword ParamAssignmentList
#   ParamKeyword ::= "param"
#   ParamAssignmentList ::= "(" ( AssignmentList | VariableList ) ")"
#   AssignmentList ::= VariableAssignment { "," VariableAssignment }
#   VariableAssignment ::= VariableRef AssignmentChar Identifier
#   VariableList ::= VariableEntry { "," VariableEntry }
#   VariableEntry ::= VariableRef | Minus
#   GetReplyStatement ::= PortOrAny Dot PortGetReplyOp
#   PortGetReplyOp ::= GetReplyOpKeyword [ "(" InLineTemplate [ ValueMatchSpec ] ")" ] [ FromClause ] [ PortRedirectWithValueAndParam ]
#   PortRedirectWithValueAndParam ::= PortRedirectSymbol RedirectWithValueAndParamSpec
#   RedirectWithValueAndParamSpec ::= ValueSpec [ ParamSpec ] [ SenderSpec ] | RedirectWithParamSpec
#   GetReplyOpKeyword ::= "getreply"
#   ValueMatchSpec ::= ValueKeyword InLineTemplate
#   CheckStatement ::= PortOrAny Dot PortCheckOp
#   PortCheckOp ::= CheckOpKeyword [ "(" CheckParameter ")" ]
#   CheckOpKeyword ::= "check"
#   CheckParameter ::= CheckPortOpsPresent | FromClausePresent | RedirectPresent
#   FromClausePresent ::= FromClause [ PortRedirectSymbol SenderSpec ]
#   RedirectPresent ::= PortRedirectSymbol SenderSpec
#   CheckPortOpsPresent ::= PortReceiveOp | PortGetCallOp | PortGetReplyOp | PortCatchOp
#   CatchStatement ::= PortOrAny Dot PortCatchOp
#   PortCatchOp ::= CatchOpKeyword [ "(" CatchOpParameter ")" ] [ FromClause ] [ PortRedirect ]
#   CatchOpKeyword ::= "catch"
#   CatchOpParameter ::= Signature "," InLineTemplate | TimeoutKeyword
#   ClearStatement ::= PortOrAll Dot ClearOpKeyword
#   PortOrAll ::= ArrayIdentifierRef | AllKeyword PortKeyword
#   ClearOpKeyword ::= "clear"
#   StartStatement ::= PortOrAll Dot StartKeyword
#   StopStatement ::= PortOrAll Dot StopKeyword
#   StopKeyword ::= "stop"
#   HaltStatement ::= PortOrAll Dot HaltKeyword
#   HaltKeyword ::= "halt"
#   AnyKeyword ::= "any"
#   CheckStateStatement ::= PortOrAllAny Dot CheckStateKeyword "(" SingleExpression ")"
#   PortOrAllAny ::= PortOrAll | AnyKeyword PortKeyword
#   CheckStateKeyword ::= "checkstate"
#   TimerStatements ::= StartTimerStatement | StopTimerStatement | TimeoutStatement
#   TimerOps ::= ReadTimerOp | RunningTimerOp
#   StartTimerStatement ::= ArrayIdentifierRef Dot StartKeyword [ "(" Expression ")" ]
#   StopTimerStatement ::= TimerRefOrAll Dot StopKeyword
#   TimerRefOrAll ::= ArrayIdentifierRef | AllKeyword TimerKeyword
#   ReadTimerOp ::= ArrayIdentifierRef Dot ReadKeyword
#   ReadKeyword ::= "read"
#   RunningTimerOp ::= TimerRefOrAny Dot RunningKeyword
#   TimeoutStatement ::= TimerRefOrAny Dot TimeoutKeyword
#   TimerRefOrAny ::= ArrayIdentifierRef | ( AnyKeyword TimerKeyword )
#   TimeoutKeyword ::= "timeout"
#   TestcaseOperation ::= TestcaseKeyword "." StopKeyword [ "(" { ( FreeText | InLineTemplate ) [ "," ] } ")" ]
#   Type ::= PredefinedType | ReferencedType
#   PredefinedType ::= BitStringKeyword | BooleanKeyword | CharStringKeyword | UniversalCharString | IntegerKeyword | OctetStringKeyword | HexStringKeyword | VerdictTypeKeyword | FloatKeyword | AddressKeyword | DefaultKeyword | AnyTypeKeyword
#   BitStringKeyword ::= "bitstring"
#   BooleanKeyword ::= "boolean"
#   IntegerKeyword ::= "integer"
#   OctetStringKeyword ::= "octetstring"
#   HexStringKeyword ::= "hexstring"
#   VerdictTypeKeyword ::= "verdicttype"
#   FloatKeyword ::= "float"
#   AddressKeyword ::= "address"
#   DefaultKeyword ::= "default"
#   AnyTypeKeyword ::= "anytype"
#   CharStringKeyword ::= "charstring"
#   UniversalCharString ::= UniversalKeyword CharStringKeyword
#   UniversalKeyword ::= "universal"
#   ReferencedType ::= ExtendedIdentifier [ ExtendedFieldReference ]
#   TypeReference ::= Identifier
#   ArrayDef ::= { "[" SingleExpression [ ".." SingleExpression ] "]" }+
#   Value ::= PredefinedValue | ReferencedValue
#   PredefinedValue ::= Bstring | BooleanValue | CharStringValue | Number | Ostring | Hstring | VerdictTypeValue | Identifier | FloatValue | AddressValue | OmitKeyword
#   BooleanValue ::= "true" | "false"
#   VerdictTypeValue ::= "pass" | "fail" | "inconc" | "none" | "error"
#   CharStringValue ::= Cstring | Quadruple
#   Quadruple ::= CharKeyword "(" Number "," Number "," Number "," Number ")"
#   CharKeyword ::= "char"
#   FloatValue ::= FloatDotNotation | FloatENotation | NaNKeyword
#   NaNKeyword ::= "not_a_number"
#   FloatDotNotation ::= Number Dot DecimalNumber
#   FloatENotation ::= Number [ Dot DecimalNumber ] Exponential [ Minus ] Number
#   Exponential ::= "E"
#   ReferencedValue ::= ExtendedIdentifier [ ExtendedFieldReference ]
#   Number ::= ( NonZeroNum { Num } ) | "0"
#   NonZeroNum ::= "1" | "2" | "3" | "4" | "5" | "6" | "7" | "8" | "9"
#   DecimalNumber ::= { Num }+
#   Num ::= "0" | NonZeroNum
#   Bstring ::= "'" { Bin } "'" "B"
#   Bin ::= "0" | "1"
#   Hstring ::= "'" { Hex } "'" "H"
#   Hex ::= Num | "A" | "B" | "C" | "D" | "E" | "F" | "a" | "b" | "c" | "d" | "e" | "f"
#   Ostring ::= "'" { Oct } "'" "O"
#   Oct ::= Hex Hex
#   Cstring ::= """ { Char } """
#   Char ::= 
#   Identifier ::= Alpha { AlphaNum | Underscore }
#   Alpha ::= UpperAlpha | LowerAlpha
#   AlphaNum ::= Alpha | Num
#   UpperAlpha ::= "A" | "B" | "C" | "D" | "E" | "F" | "G" | "H" | "I" | "J" | "K" | "L" | "M" | "N" | "O" | "P" | "Q" | "R" | "S" | "T" | "U" | "V" | "W" | "X" | "Y" | "Z"
#   LowerAlpha ::= "a" | "b" | "c" | "d" | "e" | "f" | "g" | "h" | "i" | "j" | "k" | "l" | "m" | "n" | "o" | "p" | "q" | "r" | "s" | "t" | "u" | "v" | "w" | "x" | "y" | "z"
#   ExtendedAlphaNum ::= 
#   FreeText ::= """ { ExtendedAlphaNum } """
#   AddressValue ::= "null"
#   OmitKeyword ::= "omit"
#   InParKeyword ::= "in"
#   OutParKeyword ::= "out"
#   InOutParKeyword ::= "inout"
#   FormalValuePar ::= [ ( InParKeyword | InOutParKeyword | OutParKeyword ) ] Type Identifier [ ":=" ( Expression | Minus ) ]
#   FormalPortPar ::= [ InOutParKeyword ] Identifier Identifier
#   FormalTimerPar ::= [ InOutParKeyword ] TimerKeyword Identifier
#   FormalTemplatePar ::= [ ( InParKeyword | OutParKeyword | InOutParKeyword ) ] ( TemplateKeyword | RestrictedTemplate ) Type Identifier [ ":=" ( InLineTemplate | Minus ) ]
#   RestrictedTemplate ::= OmitKeyword | ( TemplateKeyword TemplateRestriction )
#   TemplateRestriction ::= "(" ( OmitKeyword | ValueKeyword | PresentKeyword ) ")"
#   WithStatement ::= WithKeyword WithAttribList
#   WithKeyword ::= "with"
#   WithAttribList ::= "{" MultiWithAttrib "}"
#   MultiWithAttrib ::= { SingleWithAttrib [ SemiColon ] }
#   SingleWithAttrib ::= AttribKeyword [ OverrideKeyword ] [ AttribQualifier ] FreeText
#   AttribKeyword ::= EncodeKeyword | VariantKeyword | DisplayKeyword | ExtensionKeyword | OptionalKeyword
#   EncodeKeyword ::= "encode"
#   VariantKeyword ::= "variant"
#   DisplayKeyword ::= "display"
#   ExtensionKeyword ::= "extension"
#   OverrideKeyword ::= "override"
#   AttribQualifier ::= "(" DefOrFieldRefList ")"
#   DefOrFieldRefList ::= DefOrFieldRef { "," DefOrFieldRef }
#   DefOrFieldRef ::= QualifiedIdentifier | ( ( FieldReference | "[" Minus "]" ) [ ExtendedFieldReference ] ) | AllRef
#   QualifiedIdentifier ::= { Identifier Dot } Identifier
#   AllRef ::= ( GroupKeyword AllKeyword [ ExceptKeyword "{" QualifiedIdentifierList "}" ] ) | ( ( TypeDefKeyword | TemplateKeyword | ConstKeyword | AltstepKeyword | TestcaseKeyword | FunctionKeyword | SignatureKeyword | ModuleParKeyword ) AllKeyword [ ExceptKeyword "{" IdentifierList "}" ] )
#   BehaviourStatements ::= TestcaseInstance | FunctionInstance | ReturnStatement | AltConstruct | InterleavedConstruct | LabelStatement | GotoStatement | RepeatStatement | DeactivateStatement | AltstepInstance | ActivateOp | BreakStatement | ContinueStatement
#   SetLocalVerdict ::= SetVerdictKeyword "(" SingleExpression { "," LogItem } ")"
#   SetVerdictKeyword ::= "setverdict"
#   GetLocalVerdict ::= "getverdict"
#   SUTStatements ::= ActionKeyword "(" ActionText { StringOp ActionText } ")"
#   ActionKeyword ::= "action"
#   ActionText ::= FreeText | Expression
#   ReturnStatement ::= ReturnKeyword [ Expression | InLineTemplate ]
#   AltConstruct ::= AltKeyword "{" AltGuardList "}"
#   AltKeyword ::= "alt"
#   AltGuardList ::= { GuardStatement | ElseStatement [ SemiColon ] }
#   GuardStatement ::= AltGuardChar ( AltstepInstance [ StatementBlock ] | GuardOp StatementBlock )
#   ElseStatement ::= "[" ElseKeyword "]" StatementBlock
#   AltGuardChar ::= "[" [ BooleanExpression ] "]"
#   GuardOp ::= TimeoutStatement | ReceiveStatement | TriggerStatement | GetCallStatement | CatchStatement | CheckStatement | GetReplyStatement | DoneStatement | KilledStatement
#   InterleavedConstruct ::= InterleavedKeyword "{" InterleavedGuardList "}"
#   InterleavedKeyword ::= "interleave"
#   InterleavedGuardList ::= { InterleavedGuardElement [ SemiColon ] }+
#   InterleavedGuardElement ::= InterleavedGuard StatementBlock
#   InterleavedGuard ::= "[" "]" GuardOp
#   LabelStatement ::= LabelKeyword Identifier
#   LabelKeyword ::= "label"
#   GotoStatement ::= GotoKeyword Identifier
#   GotoKeyword ::= "goto"
#   RepeatStatement ::= "repeat"
#   ActivateOp ::= ActivateKeyword "(" AltstepInstance ")"
#   ActivateKeyword ::= "activate"
#   DeactivateStatement ::= DeactivateKeyword [ "(" ComponentOrDefaultReference ")" ]
#   DeactivateKeyword ::= "deactivate"
#   BreakStatement ::= "break"
#   ContinueStatement ::= "continue"
#   BasicStatements ::= Assignment | LogStatement | LoopConstruct | ConditionalConstruct | SelectCaseConstruct | StatementBlock
#   Expression ::= SingleExpression | CompoundExpression
#   CompoundExpression ::= FieldExpressionList | ArrayExpression
#   FieldExpressionList ::= "{" FieldExpressionSpec { "," FieldExpressionSpec } "}"
#   FieldExpressionSpec ::= FieldReference AssignmentChar NotUsedOrExpression
#   ArrayExpression ::= "{" [ ArrayElementExpressionList ] "}"
#   ArrayElementExpressionList ::= NotUsedOrExpression { "," NotUsedOrExpression }
#   NotUsedOrExpression ::= Expression | Minus
#   ConstantExpression ::= SingleExpression | CompoundConstExpression
#   BooleanExpression ::= SingleExpression
#   CompoundConstExpression ::= FieldConstExpressionList | ArrayConstExpression
#   FieldConstExpressionList ::= "{" FieldConstExpressionSpec { "," FieldConstExpressionSpec } "}"
#   FieldConstExpressionSpec ::= FieldReference AssignmentChar ConstantExpression
#   ArrayConstExpression ::= "{" [ ArrayElementConstExpressionList ] "}"
#   ArrayElementConstExpressionList ::= ConstantExpression { "," ConstantExpression }
#   Assignment ::= VariableRef AssignmentChar ( Expression | TemplateBody )
#   SingleExpression ::= XorExpression { "or" XorExpression }
#   XorExpression ::= AndExpression { "xor" AndExpression }
#   AndExpression ::= NotExpression { "and" NotExpression }
#   NotExpression ::= [ "not" ] EqualExpression
#   EqualExpression ::= RelExpression { EqualOp RelExpression }
#   RelExpression ::= ShiftExpression [ RelOp ShiftExpression ] | CompoundExpression
#   ShiftExpression ::= BitOrExpression { ShiftOp BitOrExpression }
#   BitOrExpression ::= BitXorExpression { "or4b" BitXorExpression }
#   BitXorExpression ::= BitAndExpression { "xor4b" BitAndExpression }
#   BitAndExpression ::= BitNotExpression { "and4b" BitNotExpression }
#   BitNotExpression ::= [ "not4b" ] AddExpression
#   AddExpression ::= MulExpression { AddOp MulExpression }
#   MulExpression ::= UnaryExpression { MultiplyOp UnaryExpression } | CompoundExpression
#   UnaryExpression ::= [ UnaryOp ] Primary
#   Primary ::= OpCall | Value | "(" SingleExpression ")"
#   ExtendedFieldReference ::= { ( Dot ( Identifier | PredefinedType ) ) | ArrayOrBitRef | ( "[" Minus "]" ) }+
#   OpCall ::= ConfigurationOps | GetLocalVerdict | TimerOps | TestcaseInstance | ( FunctionInstance [ ExtendedFieldReference ] ) | ( TemplateOps [ ExtendedFieldReference ] ) | ActivateOp
#   AddOp ::= "+" | "-" | StringOp
#   MultiplyOp ::= "*" | "/" | "mod" | "rem"
#   UnaryOp ::= "+" | "-"
#   RelOp ::= "<" | ">" | ">=" | "<="
#   EqualOp ::= "==" | "!="
#   StringOp ::= "&"
#   ShiftOp ::= "<<" | ">>" | "<@" | "@>"
#   LogStatement ::= LogKeyword "(" LogItem { "," LogItem } ")"
#   LogKeyword ::= "log"
#   LogItem ::= FreeText | InLineTemplate
#   LoopConstruct ::= ForStatement | WhileStatement | DoWhileStatement
#   ForStatement ::= ForKeyword "(" Initial SemiColon BooleanExpression SemiColon Assignment ")" StatementBlock
#   ForKeyword ::= "for"
#   Initial ::= VarInstance | Assignment
#   WhileStatement ::= WhileKeyword "(" BooleanExpression ")" StatementBlock
#   WhileKeyword ::= "while"
#   DoWhileStatement ::= DoKeyword StatementBlock WhileKeyword "(" BooleanExpression ")"
#   DoKeyword ::= "do"
#   ConditionalConstruct ::= IfKeyword "(" BooleanExpression ")" StatementBlock { ElseIfClause } [ ElseClause ]
#   IfKeyword ::= "if"
#   ElseIfClause ::= ElseKeyword IfKeyword "(" BooleanExpression ")" StatementBlock
#   ElseKeyword ::= "else"
#   ElseClause ::= ElseKeyword StatementBlock
#   SelectCaseConstruct ::= SelectKeyword "(" SingleExpression ")" SelectCaseBody
#   SelectKeyword ::= "select"
#   SelectCaseBody ::= "{" { SelectCase }+ "}"

   # SelectCase ::= CaseKeyword ( "(" InLineTemplate { "," InLineTemplate } ")" | ElseKeyword ) StatementBlock
   SelectCase = CaseKeyword & ( Literal("(") & InLineTemplate & ( Literal(",") & InLineTemplate ) & Literal(")" ) | ElseKeyword ) & StatementBlock
   
   # CaseKeyword ::= "case"
   CaseKeyword = Literal("case");

   # ExtendedIdentifier     ::=     [ Identifier Dot ] Identifier
   ExtendedIdentifier = ( Identifier & Dot )[:1] & Identifier

   # IdentifierList   ::=    Identifier { "," Identifier }
   IdentifierList = Identifier & ( Literal(",") & Identifier )[:]

   # QualifiedIdentifierList   ::=    QualifiedIdentifier { "," QualifiedIdentifier }
   QualifiedIdentifierList = QualifiedIdentifier & (Literal(",") & QualifiedIdentifier)[:];

   # Dot     ::=     "."
   Dot = Literal(".")

   # Minus   ::=     "-"
   Minus = Literal("-")

   # SemiColon     ::=     ";"
   SemiColon = Literal(";");

   # Colon   ::=     ":"
   Colon = Literal(":");

   # Underscore    ::=     "_"
   Underscore = Literal("_");

   # AssignmentChar   ::=     ":="
   AssignmentChar = Literal(":=");
   
   # TTCN3Module ::= TTCN3ModuleKeyword ModuleId "{" [ ModuleDefinitionsList ] [ ModuleControlPart ] "}" [ WithStatement ] [ SemiColon ]
   TTCN3Module = TTCN3ModuleKeyword & ModuleId & Literal("{") & ( ModuleDefinitionsList )[:1] & ( ModuleControlPart )[:1] & Literal("}") & ( WithStatement )[:1] & ( SemiColon )[:1]

def parse(text):
   TTCN3Module.config.auto_memoize(full=True);
   print "->", list(TTCN3Module.parse_all(text));
